'use server';

import { db } from '@/lib/db';
import { users } from '@/db/schema';
import { eq } from 'drizzle-orm';
import { createClient } from '@/lib/supabase/server';
import { generateUsername } from '@/lib/auth/username-service';

/**
 * Generate a secure temporary password
 * 16 characters with mixed case, numbers, and special characters
 */
export function generateSecurePassword(): string {
  const length = 16;
  const uppercase = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';
  const lowercase = 'abcdefghijklmnopqrstuvwxyz';
  const numbers = '0123456789';
  const special = '!@#$%^&*';
  const allChars = uppercase + lowercase + numbers + special;

  let password = '';

  // Ensure at least one of each type
  password += uppercase[Math.floor(Math.random() * uppercase.length)];
  password += lowercase[Math.floor(Math.random() * lowercase.length)];
  password += numbers[Math.floor(Math.random() * numbers.length)];
  password += special[Math.floor(Math.random() * special.length)];

  // Fill rest with random characters
  for (let i = password.length; i < length; i++) {
    password += allChars[Math.floor(Math.random() * allChars.length)];
  }

  // Shuffle the password
  return password
    .split('')
    .sort(() => Math.random() - 0.5)
    .join('');
}

interface CreateSandboxUserData {
  email?: string;
  preferredUsername?: string;
  accountType: 'individual' | 'team' | 'enterprise';
  roleHierarchy:
    | 'user'
    | 'team_user'
    | 'team_admin'
    | 'team_super_admin'
    | 'enterprise_user'
    | 'enterprise_admin'
    | 'enterprise_super_admin';
  companyId?: string;
  fullName?: string;
}

/**
 * Create a sandbox user with auto-generated credentials
 */
export async function createSandboxUser(data: CreateSandboxUserData): Promise<{
  success: boolean;
  userId?: string;
  username?: string;
  password?: string;
  error?: string;
}> {
  try {
    const supabase = await createClient();

    // Generate username
    const { username, error: usernameError } = await generateUsername(
      data.preferredUsername
    );
    if (usernameError) {
      return { success: false, error: usernameError };
    }

    // Generate secure password
    const password = generateSecurePassword();

    // Generate email if not provided
    // Use a sandbox-specific domain, not @easemail.com
    const email = data.email || `${username}@sandbox.local`;

    // Create Supabase Auth user
    const { data: authData, error: authError } =
      await supabase.auth.admin.createUser({
        email,
        password,
        email_confirm: true, // Auto-confirm sandbox users
        user_metadata: {
          username,
          full_name: data.fullName || username,
          is_sandbox_user: true,
        },
      });

    if (authError || !authData.user) {
      console.error('Supabase Auth error:', authError);
      return {
        success: false,
        error: authError?.message || 'Failed to create auth user',
      };
    }

    // Create user record in database
    await db.insert(users).values({
      id: authData.user.id,
      email,
      username,
      fullName: data.fullName || username,
      accountType: data.accountType,
      roleHierarchy: data.roleHierarchy,
      role: 'sandbox_user', // Legacy role for backwards compatibility
      isSandboxUser: true,
      sandboxAutoGeneratedPassword: true,
      sandboxCompanyId: data.companyId || null,
      subscriptionTier:
        data.accountType === 'enterprise'
          ? 'enterprise'
          : data.accountType === 'team'
            ? 'team'
            : 'individual',
      createdAt: new Date(),
      updatedAt: new Date(),
    });

    // Send credentials email
    await sendSandboxUserCredentials(authData.user.id, username, password);

    return {
      success: true,
      userId: authData.user.id,
      username,
      password,
    };
  } catch (error) {
    console.error('Error creating sandbox user:', error);
    return {
      success: false,
      error: 'Failed to create sandbox user',
    };
  }
}

/**
 * Send sandbox user credentials via email
 * This would integrate with the notification system
 */
async function sendSandboxUserCredentials(
  userId: string,
  username: string,
  tempPassword: string
): Promise<void> {
  try {
    // TODO: Integrate with notification template system
    // For now, just log the credentials
    console.log('=== SANDBOX USER CREDENTIALS ===');
    console.log(`User ID: ${userId}`);
    console.log(`Username: ${username}`);
    console.log(`Temporary Password: ${tempPassword}`);
    console.log(`Login URL: ${process.env.NEXT_PUBLIC_APP_URL}/login`);
    console.log('================================');

    // Future implementation:
    // await sendNotification({
    //   templateSlug: 'sandbox_user_credentials',
    //   userId,
    //   variables: {
    //     username,
    //     temporary_password: tempPassword,
    //     login_url: `${process.env.NEXT_PUBLIC_APP_URL}/login`,
    //   },
    // });
  } catch (error) {
    console.error('Error sending credentials email:', error);
    // Don't throw - user creation succeeded, email is secondary
  }
}

/**
 * Update sandbox user credentials after they change their password
 */
export async function clearSandboxAutoGeneratedFlag(
  userId: string
): Promise<{ success: boolean; error?: string }> {
  try {
    await db
      .update(users)
      .set({ sandboxAutoGeneratedPassword: false })
      .where(eq(users.id, userId));

    return { success: true };
  } catch (error) {
    console.error('Error clearing sandbox flag:', error);
    return {
      success: false,
      error: 'Failed to update sandbox user status',
    };
  }
}
