'use client';

import { useState, useRef, useEffect } from 'react';
import { createPortal } from 'react-dom';
import {
  X,
  Send,
  Paperclip,
  Smile,
  AtSign,
  Minimize2,
  Maximize2,
  Sparkles,
  Mic,
  MicOff,
  FileText,
  Clock,
} from 'lucide-react';
import { toast, confirmDialog } from '@/lib/toast';
import { sendEmailAction } from '@/lib/chat/actions';
import { RichTextEditor } from './RichTextEditor';
import { AttachmentList, type Attachment } from './AttachmentList';
import { TemplateModal } from './TemplateModal';
import { SchedulePicker } from './SchedulePicker';
import {
  saveDraft,
  deleteDraft,
  getRecentDraft,
} from '@/lib/email/draft-actions';
import { scheduleEmail } from '@/lib/email/scheduler-actions';
import EmojiPicker, { EmojiClickData } from 'emoji-picker-react';

interface SpeechRecognition extends EventTarget {
  continuous: boolean;
  interimResults: boolean;
  lang: string;
  start(): void;
  stop(): void;
  onresult: (event: any) => void;
  onerror: (event: any) => void;
  onend: () => void;
}

interface SpeechRecognitionConstructor {
  new (): SpeechRecognition;
}

declare global {
  interface Window {
    SpeechRecognition: SpeechRecognitionConstructor;
    webkitSpeechRecognition: SpeechRecognitionConstructor;
  }
}

interface EmailComposerProps {
  isOpen: boolean;
  onClose: () => void;
  mode?: 'compose' | 'reply' | 'forward';
  initialData?: {
    to?: string;
    subject?: string;
    body?: string;
  };
}

export function EmailComposer({
  isOpen,
  onClose,
  mode = 'compose',
  initialData,
}: EmailComposerProps): JSX.Element | null {
  const [to, setTo] = useState(initialData?.to || '');
  const [cc, setCc] = useState('');
  const [bcc, setBcc] = useState('');
  const [subject, setSubject] = useState(initialData?.subject || '');
  const [body, setBody] = useState(initialData?.body || '');
  const [showCc, setShowCc] = useState(false);
  const [showBcc, setShowBcc] = useState(false);
  const [isMinimized, setIsMinimized] = useState(false);
  const [isSending, setIsSending] = useState(false);
  const [isRemixing, setIsRemixing] = useState(false);
  const [isDictating, setIsDictating] = useState(false);
  const [mounted, setMounted] = useState(false);
  const [previousBody, setPreviousBody] = useState('');
  const [attachments, setAttachments] = useState<Attachment[]>([]);
  const [isUploading, setIsUploading] = useState(false);
  const [showEmojiPicker, setShowEmojiPicker] = useState(false);
  const [showTemplateModal, setShowTemplateModal] = useState(false);
  const [showSchedulePicker, setShowSchedulePicker] = useState(false);
  const [isDragging, setIsDragging] = useState(false);
  const [draftId, setDraftId] = useState<string | null>(null);
  const [saveStatus, setSaveStatus] = useState<'idle' | 'saving' | 'saved'>('idle');
  const [showSendMenu, setShowSendMenu] = useState(false);
  const bodyRef = useRef<HTMLTextAreaElement>(null);
  const dictationRecognitionRef = useRef<SpeechRecognition | null>(null);
  const fileInputRef = useRef<HTMLInputElement>(null);
  const autoSaveTimeoutRef = useRef<NodeJS.Timeout | null>(null);

  // Mount check for portal
  useEffect(() => {
    setMounted(true);
    return () => setMounted(false);
  }, []);

  // Keyboard shortcuts
  useEffect(() => {
    if (!isOpen || isMinimized) return;

    const handleKeyDown = (e: KeyboardEvent) => {
      // Cmd/Ctrl + Enter: Send email
      if ((e.metaKey || e.ctrlKey) && e.key === 'Enter') {
        e.preventDefault();
        handleSend();
      }

      // Cmd/Ctrl + S: Manual save draft
      if ((e.metaKey || e.ctrlKey) && e.key === 's') {
        e.preventDefault();
        // Draft is auto-saved, just show a toast
        toast.success('Draft saved');
      }

      // Escape: Close composer (with confirmation if has content)
      if (e.key === 'Escape' && !showEmojiPicker && !showTemplateModal && !showSchedulePicker) {
        e.preventDefault();
        handleClose();
      }
    };

    window.addEventListener('keydown', handleKeyDown);
    return () => window.removeEventListener('keydown', handleKeyDown);
  }, [isOpen, isMinimized, to, subject, body, showEmojiPicker, showTemplateModal, showSchedulePicker]);

  // Calculate character and word count
  const getTextStats = () => {
    const plainText = body.replace(/<[^>]*>/g, '');
    const charCount = plainText.length;
    const wordCount = plainText.trim().split(/\s+/).filter(Boolean).length;
    return { charCount, wordCount };
  };

  // Initialize speech recognition for dictation
  useEffect(() => {
    if (typeof window !== 'undefined') {
      const SpeechRecognitionAPI =
        window.SpeechRecognition || window.webkitSpeechRecognition;
      if (SpeechRecognitionAPI) {
        const recognition = new SpeechRecognitionAPI();
        recognition.continuous = true; // Keep listening
        recognition.interimResults = true; // Real-time text
        recognition.lang = 'en-US';

        recognition.onresult = (event: any) => {
          let finalTranscript = '';
          for (let i = event.resultIndex; i < event.results.length; i++) {
            if (event.results[i].isFinal) {
              finalTranscript += event.results[i][0].transcript + ' ';
            }
          }
          if (finalTranscript) {
            setBody((prev) => prev + finalTranscript);
          }
        };

        recognition.onerror = (event: any) => {
          console.error('Dictation error:', event.error);
          setIsDictating(false);
          toast.error('Dictation error. Please try again.');
        };

        recognition.onend = () => setIsDictating(false);
        dictationRecognitionRef.current = recognition;
      }
    }
  }, []);

  // Update fields when initialData changes
  useEffect(() => {
    if (initialData) {
      if (initialData.to) setTo(initialData.to);
      if (initialData.subject) setSubject(initialData.subject);
      if (initialData.body) setBody(initialData.body);
    }
  }, [initialData]);

  // Load the most recent draft when composer opens (if no initial data)
  useEffect(() => {
    const loadRecentDraft = async () => {
      if (isOpen && !initialData?.to && !initialData?.subject && !initialData?.body) {
        const result = await getRecentDraft();
        if (result.success && result.draft) {
          const draft = result.draft;
          setDraftId(draft.id);
          setTo(draft.to || '');
          setCc(draft.cc || '');
          setBcc(draft.bcc || '');
          setSubject(draft.subject || '');
          setBody(draft.body || '');
          if (draft.attachments && Array.isArray(draft.attachments)) {
            setAttachments(draft.attachments as Attachment[]);
          }
          setSaveStatus('saved');
        }
      }
    };

    loadRecentDraft();
  }, [isOpen, initialData]);

  // Auto-save draft with debouncing
  useEffect(() => {
    // Don't auto-save if composer is closed or minimized
    if (!isOpen || isMinimized) return;

    // Don't auto-save if nothing is entered
    if (!to && !subject && !body && attachments.length === 0) {
      return;
    }

    // Clear existing timeout
    if (autoSaveTimeoutRef.current) {
      clearTimeout(autoSaveTimeoutRef.current);
    }

    // Set new timeout for auto-save (debounce for 2 seconds)
    autoSaveTimeoutRef.current = setTimeout(async () => {
      setSaveStatus('saving');

      const result = await saveDraft({
        draftId: draftId || undefined,
        draftData: {
          to,
          cc: cc || undefined,
          bcc: bcc || undefined,
          subject,
          body,
          attachments,
          mode,
        },
      });

      if (result.success && result.draftId) {
        setDraftId(result.draftId);
        setSaveStatus('saved');

        // Reset to idle after 2 seconds
        setTimeout(() => {
          setSaveStatus('idle');
        }, 2000);
      } else {
        setSaveStatus('idle');
        console.error('Failed to save draft:', result.error);
      }
    }, 2000); // 2 second debounce

    // Cleanup function
    return () => {
      if (autoSaveTimeoutRef.current) {
        clearTimeout(autoSaveTimeoutRef.current);
      }
    };
  }, [to, cc, bcc, subject, body, attachments, isOpen, isMinimized, mode, draftId]);

  // Auto-focus body when composer opens
  useEffect(() => {
    if (isOpen && !isMinimized && bodyRef.current) {
      bodyRef.current.focus();
    }
  }, [isOpen, isMinimized]);

  const handleSend = async (): Promise<void> => {
    if (!to || !subject || !body) {
      toast.warning('Please fill in all required fields (To, Subject, Body)');
      return;
    }

    setIsSending(true);

    try {
      // Call the actual send email action
      const result = await sendEmailAction({
        to,
        cc: cc || undefined,
        bcc: bcc || undefined,
        subject,
        body,
        attachments: attachments.map((att) => ({
          id: att.id,
          name: att.name,
          size: att.size,
          type: att.type,
          data: att.data || '',
        })),
        isHtml: true,
      });

      if (result.success) {
        // Delete draft if it exists
        if (draftId) {
          await deleteDraft(draftId);
        }

        // Reset and close
        setTo('');
        setCc('');
        setBcc('');
        setSubject('');
        setBody('');
        setAttachments([]);
        setDraftId(null);
        setSaveStatus('idle');
        onClose();

        toast.success(
          `Email ${mode === 'reply' ? 'reply' : 'sent'} successfully!`
        );
      } else {
        toast.error(result.error || 'Failed to send email');
      }
    } catch (error) {
      console.error('Failed to send email:', error);
      toast.error('Failed to send email. Please try again.');
    } finally {
      setIsSending(false);
    }
  };

  const handleClose = async (): Promise<void> => {
    if (body || subject || to) {
      const confirmed = await confirmDialog(
        'You have unsaved changes. Are you sure you want to close?'
      );
      if (!confirmed) return;
    }
    onClose();
  };

  const handleSchedule = async (scheduledFor: Date): Promise<void> => {
    if (!to || !subject || !body) {
      toast.warning('Please fill in all required fields (To, Subject, Body)');
      return;
    }

    setIsSending(true);

    try {
      const result = await scheduleEmail({
        to,
        cc: cc || undefined,
        bcc: bcc || undefined,
        subject,
        body,
        attachments,
        scheduledFor,
      });

      if (result.success) {
        // Delete draft if it exists
        if (draftId) {
          await deleteDraft(draftId);
        }

        // Reset and close
        setTo('');
        setCc('');
        setBcc('');
        setSubject('');
        setBody('');
        setAttachments([]);
        setDraftId(null);
        setSaveStatus('idle');
        onClose();

        const formattedDate = scheduledFor.toLocaleString('en-US', {
          weekday: 'short',
          month: 'short',
          day: 'numeric',
          hour: 'numeric',
          minute: '2-digit',
          hour12: true,
        });

        toast.success(`Email scheduled for ${formattedDate}`);
      } else {
        toast.error(result.error || 'Failed to schedule email');
      }
    } catch (error) {
      console.error('Failed to schedule email:', error);
      toast.error('Failed to schedule email. Please try again.');
    } finally {
      setIsSending(false);
    }
  };

  const handleRemix = async (): Promise<void> => {
    if (!body.trim()) {
      toast.warning('Please write some text to remix');
      return;
    }

    setIsRemixing(true);
    setPreviousBody(body); // Save current version for undo

    try {
      const response = await fetch('/api/ai/remix', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          text: body,
          subject,
          recipientEmail: to,
        }),
      });

      if (!response.ok) {
        throw new Error('Failed to remix text');
      }

      const data = await response.json();

      if (data.success && data.rewrittenText) {
        setBody(data.rewrittenText);
        toast.success(
          '✨ Text remixed professionally! (Previous version saved)'
        );
      }
    } catch (error) {
      console.error('Error remixing text:', error);
      toast.error('Failed to remix text. Please try again.');
    } finally {
      setIsRemixing(false);
    }
  };

  const handleDictationToggle = (): void => {
    if (!dictationRecognitionRef.current) {
      toast.error('Voice dictation not supported in this browser.');
      return;
    }

    if (isDictating) {
      dictationRecognitionRef.current.stop();
      toast.success('Dictation stopped. Click Remix to polish!');
    } else {
      try {
        dictationRecognitionRef.current.start();
        setIsDictating(true);
        toast.success('Listening... Speak naturally');
      } catch (error) {
        console.error('Error starting dictation:', error);
        toast.error('Failed to start dictation.');
      }
    }
  };

  const handleFileSelect = async (
    event: React.ChangeEvent<HTMLInputElement>
  ): Promise<void> => {
    const files = event.target.files;
    if (!files || files.length === 0) return;

    await uploadFiles(Array.from(files));
    // Reset input
    if (fileInputRef.current) {
      fileInputRef.current.value = '';
    }
  };

  const uploadFiles = async (files: File[]): Promise<void> => {
    for (const file of files) {
      const tempId = `temp-${Date.now()}-${Math.random()}`;

      // Add file with initial progress
      const newAttachment: Attachment = {
        id: tempId,
        name: file.name,
        size: file.size,
        type: file.type,
        progress: 0,
      };

      setAttachments((prev) => [...prev, newAttachment]);
      setIsUploading(true);

      try {
        const formData = new FormData();
        formData.append('file', file);

        // Simulate progress (real implementation would use XMLHttpRequest)
        const progressInterval = setInterval(() => {
          setAttachments((prev) =>
            prev.map((att) =>
              att.id === tempId &&
              att.progress !== undefined &&
              att.progress < 90
                ? { ...att, progress: att.progress + 10 }
                : att
            )
          );
        }, 100);

        const response = await fetch('/api/attachments/upload', {
          method: 'POST',
          body: formData,
        });

        clearInterval(progressInterval);

        if (!response.ok) {
          throw new Error('Upload failed');
        }

        const data = await response.json();

        // Update with final data
        setAttachments((prev) =>
          prev.map((att) =>
            att.id === tempId
              ? {
                  id: data.id,
                  name: data.name,
                  size: data.size,
                  type: data.type,
                  data: data.data,
                  progress: 100,
                }
              : att
          )
        );

        // Remove progress after a moment
        setTimeout(() => {
          setAttachments((prev) =>
            prev.map((att) =>
              att.id === data.id ? { ...att, progress: undefined } : att
            )
          );
        }, 500);
      } catch (error) {
        console.error('Error uploading file:', error);
        setAttachments((prev) =>
          prev.map((att) =>
            att.id === tempId
              ? { ...att, progress: undefined, error: 'Upload failed' }
              : att
          )
        );
        toast.error(`Failed to upload ${file.name}`);
      }
    }

    setIsUploading(false);
  };

  const handleRemoveAttachment = (id: string): void => {
    setAttachments((prev) => prev.filter((att) => att.id !== id));
  };

  const handleDrop = (event: React.DragEvent): void => {
    event.preventDefault();
    setIsDragging(false);

    const files = Array.from(event.dataTransfer.files);
    if (files.length > 0) {
      uploadFiles(files);
    }
  };

  const handleDragOver = (event: React.DragEvent): void => {
    event.preventDefault();
    setIsDragging(true);
  };

  const handleDragLeave = (): void => {
    setIsDragging(false);
  };

  const handleEmojiClick = (emojiData: EmojiClickData): void => {
    // Append emoji to body
    setBody((prev) => prev + emojiData.emoji);
    setShowEmojiPicker(false);
  };

  const handleSelectTemplate = (
    templateSubject: string,
    templateBody: string
  ): void => {
    setSubject(templateSubject);
    setBody(templateBody);
    toast.success('Template applied successfully');
  };

  if (!isOpen || !mounted) return null;

  const modalContent = (
    <>
      {/* Backdrop */}
      {!isMinimized && (
        <div
          className="fixed inset-0 bg-black/50 backdrop-blur-sm"
          style={{ zIndex: 9998 }}
          onClick={handleClose}
        />
      )}

      {/* Composer Window */}
      <div
        className="fixed flex flex-col overflow-hidden rounded-lg border border-white/20 bg-white shadow-2xl dark:bg-gray-900"
        style={
          !isMinimized
            ? {
                zIndex: 9999,
                position: 'fixed',
                left: '50%',
                top: '50%',
                transform: 'translate(-50%, -50%)',
                width: '900px',
                height: '700px',
                maxWidth: '90vw',
                maxHeight: '90vh',
              }
            : {
                zIndex: 50,
                position: 'fixed',
                bottom: '1rem',
                right: '1rem',
                width: '320px',
                height: '56px',
              }
        }
      >
        {/* Header */}
        <div className="flex items-center justify-between border-b border-gray-200/80 bg-white/60 px-4 py-3 dark:border-white/10 dark:bg-white/5">
          <h2 className="font-semibold text-gray-900 dark:text-white">
            {mode === 'reply'
              ? 'Reply'
              : mode === 'forward'
                ? 'Forward'
                : 'New Message'}
          </h2>
          <div className="flex items-center gap-2">
            <button
              type="button"
              onClick={() => setIsMinimized(!isMinimized)}
              className="rounded-md p-1.5 text-gray-600 transition-colors hover:bg-gray-100 dark:text-gray-400 dark:hover:bg-gray-800"
              aria-label={isMinimized ? 'Maximize' : 'Minimize'}
            >
              {isMinimized ? (
                <Maximize2 className="h-4 w-4" />
              ) : (
                <Minimize2 className="h-4 w-4" />
              )}
            </button>
            <button
              type="button"
              onClick={handleClose}
              className="rounded-md p-1.5 text-gray-600 transition-colors hover:bg-gray-100 dark:text-gray-400 dark:hover:bg-gray-800"
              aria-label="Close"
            >
              <X className="h-4 w-4" />
            </button>
          </div>
        </div>

        {/* Composer Body */}
        {!isMinimized && (
          <div
            className="flex flex-1 flex-col overflow-hidden relative"
            onDrop={handleDrop}
            onDragOver={handleDragOver}
            onDragLeave={handleDragLeave}
          >
            {/* Drag and Drop Overlay */}
            {isDragging && (
              <div className="absolute inset-0 z-50 flex items-center justify-center bg-primary/10 backdrop-blur-sm border-4 border-dashed border-primary">
                <div className="text-center">
                  <Paperclip className="mx-auto h-12 w-12 text-primary mb-2" />
                  <p className="text-lg font-semibold text-primary">
                    Drop files to attach
                  </p>
                </div>
              </div>
            )}

            {/* Recipients */}
            <div className="border-b border-gray-200/80 bg-white/40 px-4 py-3 dark:border-white/10 dark:bg-white/5">
              <div className="flex items-center gap-2">
                <label className="w-12 text-sm font-medium text-gray-700 dark:text-gray-300">
                  To:
                </label>
                <input
                  type="email"
                  value={to}
                  onChange={(e) => setTo(e.target.value)}
                  placeholder="recipient@example.com"
                  className="flex-1 bg-transparent text-sm text-gray-900 placeholder:text-gray-500 focus:outline-none dark:text-white dark:placeholder:text-gray-500"
                />
                <div className="flex items-center gap-2 text-sm">
                  {!showCc && (
                    <button
                      type="button"
                      onClick={() => setShowCc(true)}
                      className="text-gray-600 hover:text-gray-900 dark:text-gray-400 dark:hover:text-gray-100"
                    >
                      Cc
                    </button>
                  )}
                  {!showBcc && (
                    <button
                      type="button"
                      onClick={() => setShowBcc(true)}
                      className="text-gray-600 hover:text-gray-900 dark:text-gray-400 dark:hover:text-gray-100"
                    >
                      Bcc
                    </button>
                  )}
                </div>
              </div>

              {showCc && (
                <div className="mt-2 flex items-center gap-2">
                  <label className="w-12 text-sm font-medium text-gray-700 dark:text-gray-300">
                    Cc:
                  </label>
                  <input
                    type="email"
                    value={cc}
                    onChange={(e) => setCc(e.target.value)}
                    placeholder="cc@example.com"
                    className="flex-1 bg-transparent text-sm text-gray-900 placeholder:text-gray-500 focus:outline-none dark:text-white dark:placeholder:text-gray-500"
                  />
                  <button
                    type="button"
                    onClick={() => {
                      setCc('');
                      setShowCc(false);
                    }}
                    className="text-gray-600 hover:text-gray-900 dark:text-gray-400 dark:hover:text-gray-100"
                  >
                    <X className="h-4 w-4" />
                  </button>
                </div>
              )}

              {showBcc && (
                <div className="mt-2 flex items-center gap-2">
                  <label className="w-12 text-sm font-medium text-gray-700 dark:text-gray-300">
                    Bcc:
                  </label>
                  <input
                    type="email"
                    value={bcc}
                    onChange={(e) => setBcc(e.target.value)}
                    placeholder="bcc@example.com"
                    className="flex-1 bg-transparent text-sm text-gray-900 placeholder:text-gray-500 focus:outline-none dark:text-white dark:placeholder:text-gray-500"
                  />
                  <button
                    type="button"
                    onClick={() => {
                      setBcc('');
                      setShowBcc(false);
                    }}
                    className="text-gray-600 hover:text-gray-900 dark:text-gray-400 dark:hover:text-gray-100"
                  >
                    <X className="h-4 w-4" />
                  </button>
                </div>
              )}
            </div>

            {/* Subject */}
            <div className="border-b border-gray-200/80 bg-white/40 px-4 py-3 dark:border-white/10 dark:bg-white/5">
              <div className="flex items-center gap-2">
                <label className="w-12 text-sm font-medium text-gray-700 dark:text-gray-300">
                  Subject:
                </label>
                <input
                  type="text"
                  value={subject}
                  onChange={(e) => setSubject(e.target.value)}
                  placeholder="Email subject"
                  className="flex-1 bg-transparent text-sm text-gray-900 placeholder:text-gray-500 focus:outline-none dark:text-white dark:placeholder:text-gray-500"
                />
              </div>
            </div>

            {/* Body - Rich Text Editor */}
            <div className="flex-1 overflow-y-auto p-4 space-y-4">
              <RichTextEditor
                content={body}
                onChange={setBody}
                placeholder="Write your message..."
                className="h-full border-0"
              />

              {/* Attachments */}
              {attachments.length > 0 && (
                <div className="pt-4 border-t border-gray-200 dark:border-gray-700">
                  <AttachmentList
                    attachments={attachments}
                    onRemove={handleRemoveAttachment}
                  />
                </div>
              )}
            </div>

            {/* Hidden File Input */}
            <input
              ref={fileInputRef}
              type="file"
              multiple
              onChange={handleFileSelect}
              className="hidden"
              accept="image/*,.pdf,.doc,.docx,.txt,.zip"
            />

            {/* Footer */}
            <div className="flex items-center justify-between border-t border-gray-200/80 bg-white/60 px-4 py-3 dark:border-white/10 dark:bg-white/5">
              <div className="flex items-center gap-2">
                <button
                  type="button"
                  onClick={() => fileInputRef.current?.click()}
                  disabled={isUploading}
                  className="rounded-md p-2 text-gray-600 transition-colors hover:bg-gray-100 disabled:opacity-50 disabled:cursor-not-allowed dark:text-gray-400 dark:hover:bg-gray-800"
                  aria-label="Attach file"
                  title="Attach files"
                >
                  <Paperclip className="h-4 w-4" />
                </button>

                <div className="relative">
                  <button
                    type="button"
                    onClick={() => setShowEmojiPicker(!showEmojiPicker)}
                    className="rounded-md p-2 text-gray-600 transition-colors hover:bg-gray-100 dark:text-gray-400 dark:hover:bg-gray-800"
                    aria-label="Insert emoji"
                    title="Insert emoji"
                  >
                    <Smile className="h-4 w-4" />
                  </button>

                  {/* Emoji Picker Popover */}
                  {showEmojiPicker && (
                    <div className="absolute bottom-full left-0 mb-2 z-50">
                      <EmojiPicker
                        onEmojiClick={handleEmojiClick}
                        autoFocusSearch={false}
                        width={350}
                        height={400}
                      />
                    </div>
                  )}
                </div>
                <button
                  type="button"
                  className="rounded-md p-2 text-gray-600 transition-colors hover:bg-gray-100 dark:text-gray-400 dark:hover:bg-gray-800"
                  aria-label="Mention"
                >
                  <AtSign className="h-4 w-4" />
                </button>

                {/* Templates Button */}
                <button
                  type="button"
                  onClick={() => setShowTemplateModal(true)}
                  className="rounded-md p-2 text-gray-600 transition-colors hover:bg-gray-100 dark:text-gray-400 dark:hover:bg-gray-800"
                  aria-label="Templates"
                  title="Email templates"
                >
                  <FileText className="h-4 w-4" />
                </button>

                <div className="mx-2 h-6 w-px bg-gray-300 dark:bg-gray-700" />
                <button
                  type="button"
                  onClick={handleRemix}
                  disabled={isRemixing || !body.trim()}
                  className="flex items-center gap-1.5 rounded-md px-3 py-1.5 text-sm font-medium text-gray-700 transition-colors hover:bg-gray-100 disabled:cursor-not-allowed disabled:opacity-50 dark:text-gray-300 dark:hover:bg-gray-800"
                  aria-label="Remix with AI"
                  title="Rewrite and improve your text professionally"
                >
                  <Sparkles className="h-4 w-4" />
                  {isRemixing ? 'Remixing...' : 'Remix'}
                </button>

                <button
                  type="button"
                  onClick={handleDictationToggle}
                  className={`flex items-center gap-1.5 rounded-md px-3 py-1.5 text-sm font-medium transition-colors ${
                    isDictating
                      ? 'animate-pulse bg-red-500 text-white hover:bg-red-600'
                      : 'text-gray-700 hover:bg-gray-100 dark:text-gray-300 dark:hover:bg-gray-800'
                  }`}
                  aria-label="Voice Dictation"
                  title="Speak to compose your email"
                >
                  {isDictating ? (
                    <MicOff className="h-4 w-4" />
                  ) : (
                    <Mic className="h-4 w-4" />
                  )}
                  {isDictating ? 'Stop' : 'Dictate'}
                </button>
              </div>

              {/* Character/Word Count & Save Status */}
              <div className="flex items-center gap-3">
                {/* Character and Word Count */}
                {body && (
                  <div className="flex items-center gap-3 text-xs text-gray-500 dark:text-gray-400">
                    <span>{getTextStats().wordCount} words</span>
                    <span>•</span>
                    <span>{getTextStats().charCount} characters</span>
                  </div>
                )}

                {saveStatus !== 'idle' && body && (
                  <span className="text-gray-400">•</span>
                )}

                {/* Save Status Indicator */}
                {saveStatus !== 'idle' && (
                  <div className="flex items-center gap-2 text-sm text-gray-600 dark:text-gray-400">
                    {saveStatus === 'saving' ? (
                      <>
                        <div className="h-3 w-3 animate-spin rounded-full border-2 border-gray-400 border-t-transparent" />
                        <span>Saving draft...</span>
                      </>
                    ) : (
                      <>
                        <svg
                          className="h-3 w-3 text-green-500"
                          fill="none"
                          viewBox="0 0 24 24"
                          stroke="currentColor"
                        >
                          <path
                            strokeLinecap="round"
                            strokeLinejoin="round"
                            strokeWidth={2}
                            d="M5 13l4 4L19 7"
                          />
                        </svg>
                        <span className="text-green-600 dark:text-green-500">
                          Draft saved
                        </span>
                      </>
                    )}
                  </div>
                )}

                {/* Split Send Button */}
                <div className="relative flex items-center gap-0.5">
                  {/* Main Send Button */}
                  <button
                    type="button"
                    onClick={handleSend}
                    disabled={isSending || !to || !subject || !body}
                    className="flex items-center gap-2 rounded-l-lg bg-primary px-6 py-2 font-semibold text-white transition-all hover:bg-primary/90 hover:shadow-lg disabled:cursor-not-allowed disabled:opacity-50"
                  >
                    <Send className="h-4 w-4" />
                    {isSending
                      ? 'Sending...'
                      : mode === 'reply'
                        ? 'Reply'
                        : mode === 'forward'
                          ? 'Forward'
                          : 'Send'}
                  </button>

                  {/* Dropdown Toggle Button */}
                  <button
                    type="button"
                    onClick={() => setShowSendMenu(!showSendMenu)}
                    disabled={isSending || !to || !subject || !body}
                    className="flex items-center justify-center rounded-r-lg bg-primary px-2 py-2 text-white transition-all hover:bg-primary/90 hover:shadow-lg disabled:cursor-not-allowed disabled:opacity-50 border-l border-white/20"
                  >
                    <svg
                      className="h-4 w-4"
                      fill="none"
                      viewBox="0 0 24 24"
                      stroke="currentColor"
                    >
                      <path
                        strokeLinecap="round"
                        strokeLinejoin="round"
                        strokeWidth={2}
                        d="M19 9l-7 7-7-7"
                      />
                    </svg>
                  </button>

                  {/* Dropdown Menu */}
                  {showSendMenu && (
                    <div className="absolute bottom-full right-0 mb-2 w-56 rounded-lg border border-gray-200 dark:border-gray-700 bg-white dark:bg-gray-800 shadow-xl z-50">
                      <button
                        type="button"
                        onClick={() => {
                          setShowSendMenu(false);
                          handleSend();
                        }}
                        className="w-full flex items-center gap-3 px-4 py-3 text-left hover:bg-gray-100 dark:hover:bg-gray-700 rounded-t-lg transition-colors"
                      >
                        <Send size={16} className="text-primary" />
                        <div>
                          <div className="text-sm font-medium text-gray-900 dark:text-white">
                            Send now
                          </div>
                          <div className="text-xs text-gray-500 dark:text-gray-400">
                            Send email immediately
                          </div>
                        </div>
                      </button>
                      <button
                        type="button"
                        onClick={() => {
                          setShowSendMenu(false);
                          setShowSchedulePicker(true);
                        }}
                        className="w-full flex items-center gap-3 px-4 py-3 text-left hover:bg-gray-100 dark:hover:bg-gray-700 rounded-b-lg transition-colors border-t border-gray-100 dark:border-gray-700"
                      >
                        <Clock size={16} className="text-primary" />
                        <div>
                          <div className="text-sm font-medium text-gray-900 dark:text-white">
                            Schedule send...
                          </div>
                          <div className="text-xs text-gray-500 dark:text-gray-400">
                            Send email at a specific time
                          </div>
                        </div>
                      </button>
                    </div>
                  )}
                </div>
              </div>
            </div>
          )}
      </div>

      {/* Template Modal */}
      <TemplateModal
        isOpen={showTemplateModal}
        onClose={() => setShowTemplateModal(false)}
        onSelectTemplate={handleSelectTemplate}
      />

      {/* Schedule Picker Modal */}
      <SchedulePicker
        isOpen={showSchedulePicker}
        onClose={() => setShowSchedulePicker(false)}
        onSchedule={handleSchedule}
      />
    </>
  );

  return createPortal(modalContent, document.body);
}
